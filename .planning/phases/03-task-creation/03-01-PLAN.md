---
phase: 03-task-creation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/network/todoist_client.h
  - src/network/todoist_client.cpp
  - src/models/sync_queue.h
  - src/network/sync_manager.h
  - src/network/sync_manager.cpp
autonomous: true

must_haves:
  truths:
    - "TodoistClient can create a task via POST /rest/v2/tasks"
    - "SyncQueue supports create_task operation type"
    - "SyncManager can queue and process task creation operations"
  artifacts:
    - path: "src/network/todoist_client.h"
      provides: "createTask method declaration"
      contains: "createTask"
    - path: "src/network/todoist_client.cpp"
      provides: "createTask POST implementation with JSON body"
      contains: "createTask"
    - path: "src/models/sync_queue.h"
      provides: "SyncOperation with content field for create_task"
      contains: "content"
    - path: "src/network/sync_manager.h"
      provides: "queueTaskCreation method"
      contains: "queueTaskCreation"
    - path: "src/network/sync_manager.cpp"
      provides: "processNextOperation handles create_task type"
      contains: "create_task"
  key_links:
    - from: "src/network/todoist_client.cpp"
      to: "https://api.todoist.com/rest/v2/tasks"
      via: "POST with JSON body containing content field"
      pattern: "post.*tasks"
    - from: "src/network/sync_manager.cpp"
      to: "src/network/todoist_client.cpp"
      via: "m_client->createTask() called from processNextOperation"
      pattern: "createTask"
---

<objective>
Extend the backend to support creating tasks via the Todoist REST API v2 and the existing sync infrastructure.

Purpose: The existing sync pipeline (TodoistClient -> SyncManager -> SyncQueue) only supports "close_task" operations. This plan adds "create_task" support so new tasks can be submitted to Todoist (or queued offline), following the same patterns established in Phase 2.

Output: TodoistClient.createTask(), SyncQueue with content field for create_task ops, SyncManager.queueTaskCreation() — all wired and ready for the UI layer.
</objective>

<execution_context>
@/home/reg/.claude/get-shit-done/workflows/execute-plan.md
@/home/reg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/network/todoist_client.h
@src/network/todoist_client.cpp
@src/models/sync_queue.h
@src/models/sync_queue.cpp
@src/network/sync_manager.h
@src/network/sync_manager.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add createTask to TodoistClient and extend SyncOperation</name>
  <files>
    src/network/todoist_client.h
    src/network/todoist_client.cpp
    src/models/sync_queue.h
  </files>
  <action>
1. In `sync_queue.h`, add a `QString content` field to the `SyncOperation` struct. This stores the task name for "create_task" operations. Initialize it to empty string in the default constructor. Also add a `QString tempId` field for tracking optimistic UI entries (used later by AppController). The existing `taskId` field will be empty for create operations until the server responds.

2. In `todoist_client.h`, add:
   - Method: `void createTask(const QString& content)` — Creates a new task
   - Signal: `void taskCreated(const QString& content, const QString& newTaskId)` — Emitted on success with the server-assigned task ID
   - Signal: `void createTaskFailed(const QString& content, const QString& error)` — Emitted on failure
   - Private slot: `void onCreateTaskReplyFinished()` — Handles the API response

3. In `todoist_client.cpp`, implement `createTask()`:
   - POST to `https://api.todoist.com/rest/v2/tasks`
   - Set header: `Content-Type: application/json`
   - Set header: `Authorization: Bearer {token}`
   - JSON body: `{"content": "task name"}`
   - Use `QJsonDocument` to build the body (same pattern as existing JSON parsing)
   - Set 30s timeout like other requests

4. Implement `onCreateTaskReplyFinished()`:
   - Check for network errors using existing `handleNetworkError()` pattern
   - On success (HTTP 200), parse response JSON to extract the `id` field (server-assigned task ID)
   - Emit `taskCreated(content, newTaskId)` on success
   - Emit `createTaskFailed(content, errorMsg)` on failure
   - Extract content from the request body or response JSON for the signal parameter
   - Always call `reply->deleteLater()` (critical for memory management, same as existing pattern)

Note: The Todoist REST API v2 POST /tasks returns HTTP 200 (not 201) with the full task JSON object. Do NOT check for 201.
  </action>
  <verify>
Run `grep -n "createTask\|taskCreated\|createTaskFailed\|create_task" src/network/todoist_client.h src/network/todoist_client.cpp src/models/sync_queue.h` to confirm all declarations and implementations exist. Verify the code compiles: `cd /home/reg/Remarkable_Todoist && mkdir -p build && cd build && cmake .. && make 2>&1 | tail -20` (should compile without errors).
  </verify>
  <done>
TodoistClient has createTask(content) method that POSTs to Todoist API, emits taskCreated or createTaskFailed signals. SyncOperation struct has content and tempId fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend SyncManager to queue and process task creation</name>
  <files>
    src/network/sync_manager.h
    src/network/sync_manager.cpp
  </files>
  <action>
1. In `sync_manager.h`, add:
   - Method: `void queueTaskCreation(const QString& content, const QString& tempId)` — Queues a create_task operation
   - Signal: `void taskCreateSynced(const QString& tempId, const QString& serverTaskId)` — Emitted when server confirms creation
   - Signal: `void taskCreateSyncFailed(const QString& tempId, const QString& error)` — Emitted on sync failure
   - Private slot: `void onTaskCreated(const QString& content, const QString& newTaskId)` — Connected to TodoistClient::taskCreated
   - Private slot: `void onCreateTaskFailed(const QString& content, const QString& error)` — Connected to TodoistClient::createTaskFailed
   - Private member: `QString m_currentSyncContent` — Track content of current sync operation (parallel to m_currentSyncTaskId)

2. In `sync_manager.cpp` constructor, add signal connections:
   ```cpp
   connect(m_client, &TodoistClient::taskCreated, this, &SyncManager::onTaskCreated);
   connect(m_client, &TodoistClient::createTaskFailed, this, &SyncManager::onCreateTaskFailed);
   ```

3. Implement `queueTaskCreation()`:
   - Create SyncOperation with type="create_task", content=content, tempId=tempId
   - Generate uuid with QUuid::createUuid()
   - Set queuedAt to current datetime
   - Enqueue, save to file, call processQueue()
   - Follow same pattern as existing queueTaskCompletion()

4. In `processNextOperation()`, add handling for "create_task" type:
   ```cpp
   } else if (op.type == "create_task") {
       m_currentSyncContent = op.content;
       m_currentSyncTaskId = op.tempId;  // Store tempId for matching responses
       m_client->createTask(op.content);
   }
   ```

5. Implement `onTaskCreated()`:
   - Dequeue the operation, save queue
   - Set online to true (confirmed connectivity)
   - Emit taskCreateSynced(tempId, serverTaskId) — the tempId comes from m_currentSyncTaskId
   - Call processNextOperation()
   - Follow same pattern as existing onTaskClosed()

6. Implement `onCreateTaskFailed()`:
   - Follow exact same pattern as onCloseTaskFailed()
   - Detect offline from error message (timeout, connection, network, unreachable)
   - Increment retry count, max 5 retries
   - Emit taskCreateSyncFailed(tempId, error)

7. Update `sync_queue.cpp` saveToFile/loadFromFile to serialize/deserialize the new `content` and `tempId` fields in the JSON. Add them alongside existing uuid, type, taskId, queuedAt, retryCount fields.
  </action>
  <verify>
Build the project: `cd /home/reg/Remarkable_Todoist/build && cmake .. && make 2>&1 | tail -20`. Should compile without errors. Run `grep -n "queueTaskCreation\|create_task\|taskCreateSynced" src/network/sync_manager.h src/network/sync_manager.cpp` to confirm all pieces exist.
  </verify>
  <done>
SyncManager.queueTaskCreation(content, tempId) queues a create_task operation. processNextOperation() calls TodoistClient.createTask() for create_task ops. Success/failure signals emitted with tempId for UI tracking. Queue persistence includes content and tempId fields.
  </done>
</task>

</tasks>

<verification>
1. Project compiles cleanly with `cmake .. && make` in build directory
2. TodoistClient has createTask(), taskCreated, createTaskFailed signals
3. SyncManager has queueTaskCreation(), taskCreateSynced, taskCreateSyncFailed signals
4. SyncOperation struct has content and tempId fields
5. SyncQueue serializes/deserializes content and tempId to JSON
6. processNextOperation() handles both "close_task" and "create_task" types
</verification>

<success_criteria>
- Code compiles without errors
- createTask sends POST to /rest/v2/tasks with JSON body {"content": "..."}
- SyncManager queues create_task operations and processes them using same retry/offline logic as close_task
- Queue persistence round-trips content and tempId fields
</success_criteria>

<output>
After completion, create `.planning/phases/03-task-creation/03-01-SUMMARY.md`
</output>
