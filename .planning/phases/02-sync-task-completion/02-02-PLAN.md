---
phase: 02-sync-task-completion
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/models/sync_queue.h
  - src/models/sync_queue.cpp
  - CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "Sync operations can be queued with unique IDs"
    - "Queue persists to disk as JSON file"
    - "Queue survives app restart"
  artifacts:
    - path: "src/models/sync_queue.h"
      provides: "SyncQueue class declaration"
      contains: "class SyncQueue"
    - path: "src/models/sync_queue.cpp"
      provides: "JSON persistence implementation"
      contains: "sync_queue.json"
    - path: "CMakeLists.txt"
      provides: "Build includes sync_queue"
      contains: "sync_queue.cpp"
  key_links:
    - from: "src/models/sync_queue.cpp"
      to: "filesystem"
      via: "QFile at AppDataLocation"
      pattern: "QStandardPaths::AppDataLocation"
---

<objective>
Create SyncQueue class for offline operation storage with JSON persistence.

Purpose: The sync queue is the foundation for offline support. Operations must survive app crashes and restarts, so we persist to JSON before attempting any sync. This plan creates the data structure without sync logic (that comes in Plan 03).

Output: SyncQueue class that can enqueue, dequeue, peek, persist, and load sync operations from disk.
</objective>

<execution_context>
@/home/reg/.claude/get-shit-done/workflows/execute-plan.md
@/home/reg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-sync-task-completion/02-RESEARCH.md

# Patterns from existing code
@src/config/settings.h
@src/config/settings.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SyncQueue with JSON persistence</name>
  <files>src/models/sync_queue.h, src/models/sync_queue.cpp, CMakeLists.txt</files>
  <action>
Create SyncQueue class for managing offline operations:

In sync_queue.h:
```cpp
#ifndef SYNC_QUEUE_H
#define SYNC_QUEUE_H

#include <QObject>
#include <QVector>
#include <QString>
#include <QDateTime>

struct SyncOperation {
    QString uuid;           // Unique ID for idempotency (QUuid::createUuid())
    QString type;           // "close_task" for now
    QString taskId;         // Target task ID
    QDateTime queuedAt;     // When queued
    int retryCount;         // Number of sync attempts

    SyncOperation() : retryCount(0) {}
};

class SyncQueue : public QObject
{
    Q_OBJECT
    Q_PROPERTY(int count READ count NOTIFY countChanged)

public:
    explicit SyncQueue(QObject* parent = nullptr);

    // Queue operations
    void enqueue(const SyncOperation& op);
    SyncOperation dequeue();           // Remove and return front
    SyncOperation peek() const;        // View front without removing
    bool isEmpty() const;
    int count() const;
    void clear();

    // Find operation by task ID (for deduplication)
    bool hasOperationForTask(const QString& taskId, const QString& type) const;

    // Persistence
    void saveToFile();
    void loadFromFile();

signals:
    void countChanged();

private:
    QString queueFilePath() const;

    QVector<SyncOperation> m_operations;
};

#endif // SYNC_QUEUE_H
```

In sync_queue.cpp:
- Constructor: Call loadFromFile() to restore any pending operations
- enqueue(): Add to m_operations, call saveToFile() immediately, emit countChanged()
- dequeue(): Remove front, call saveToFile(), emit countChanged(), return removed op
- peek(): Return m_operations.first() (check !isEmpty() first)
- isEmpty(): Return m_operations.isEmpty()
- count(): Return m_operations.size()
- clear(): Clear m_operations, saveToFile(), emit countChanged()
- hasOperationForTask(): Linear scan for matching taskId and type
- queueFilePath(): Use QStandardPaths::writableLocation(QStandardPaths::AppDataLocation) + "/sync_queue.json"
- saveToFile():
  - Create parent directory with QDir().mkpath()
  - Serialize m_operations to QJsonArray
  - Write to file with QJsonDocument::Compact format
- loadFromFile():
  - Read file, parse JSON, populate m_operations
  - Handle missing file gracefully (no error, empty queue)
  - Handle parse errors with qWarning()

Key points:
- Use QUuid::createUuid().toString(QUuid::WithoutBraces) for UUID generation
- Save to disk BEFORE attempting any operation (crash safety)
- QStandardPaths handles the app data location correctly on reMarkable

In CMakeLists.txt:
- Add src/models/sync_queue.cpp to SOURCES
  </action>
  <verify>
Build with `cd /home/reg/Remarkable_Todoist/build && cmake .. && make -j$(nproc)` - no compile errors
Grep for "sync_queue.json" in sync_queue.cpp to confirm persistence implementation
Grep for "QStandardPaths" in sync_queue.cpp to confirm proper path usage
  </verify>
  <done>SyncQueue class exists with enqueue/dequeue/persistence working</done>
</task>

</tasks>

<verification>
1. Project builds without errors
2. SyncQueue class declared in sync_queue.h
3. JSON persistence to AppDataLocation/sync_queue.json
4. Queue operations emit countChanged signal
</verification>

<success_criteria>
- Build passes with `cmake .. && make`
- SyncQueue has enqueue, dequeue, peek, isEmpty, count, clear methods
- saveToFile/loadFromFile implement JSON persistence
- Queue file at proper location via QStandardPaths
</success_criteria>

<output>
After completion, create `.planning/phases/02-sync-task-completion/02-02-SUMMARY.md`
</output>
