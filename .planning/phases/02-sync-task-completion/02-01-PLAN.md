---
phase: 02-sync-task-completion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/network/todoist_client.h
  - src/network/todoist_client.cpp
  - src/models/taskmodel.h
  - src/models/taskmodel.cpp
autonomous: true

must_haves:
  truths:
    - "TodoistClient can close a task via API"
    - "TaskModel can mark a task as completed with UI update"
  artifacts:
    - path: "src/network/todoist_client.h"
      provides: "closeTask() method declaration"
      contains: "void closeTask"
    - path: "src/network/todoist_client.cpp"
      provides: "closeTask() implementation"
      contains: "/close"
    - path: "src/models/taskmodel.h"
      provides: "setTaskCompleted() method"
      contains: "void setTaskCompleted"
    - path: "src/models/taskmodel.cpp"
      provides: "setTaskCompleted() with dataChanged signal"
      contains: "emit dataChanged"
  key_links:
    - from: "src/network/todoist_client.cpp"
      to: "Todoist API"
      via: "POST request to /tasks/{id}/close"
      pattern: "tasks/%1/close"
    - from: "src/models/taskmodel.cpp"
      to: "QML ListView"
      via: "dataChanged signal with CompletedRole"
      pattern: "CompletedRole"
---

<objective>
Extend TodoistClient with task completion API and TaskModel with completion state management.

Purpose: These are the core building blocks for task completion - the API call to notify Todoist, and the model update to reflect changes in the UI. Both are independent and can be built in parallel within this plan.

Output: TodoistClient gains closeTask() method; TaskModel gains setTaskCompleted() method with proper signal emission for QML binding.
</objective>

<execution_context>
@/home/reg/.claude/get-shit-done/workflows/execute-plan.md
@/home/reg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-sync-task-completion/02-RESEARCH.md

# Existing code to extend
@src/network/todoist_client.h
@src/network/todoist_client.cpp
@src/models/taskmodel.h
@src/models/taskmodel.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add closeTask() to TodoistClient</name>
  <files>src/network/todoist_client.h, src/network/todoist_client.cpp</files>
  <action>
Add closeTask() method to TodoistClient:

In todoist_client.h:
- Add public method: `void closeTask(const QString& taskId);`
- Add signals: `void taskClosed(const QString& taskId);` and `void closeTaskFailed(const QString& taskId, const QString& error);`

In todoist_client.cpp:
- Implement closeTask() following existing fetchAllTasks() pattern
- POST to `https://api.todoist.com/rest/v2/tasks/{task_id}/close`
- Use Bearer token auth (same as other methods)
- Use REQUEST_TIMEOUT_MS (30 seconds) for slow WiFi
- POST with empty QByteArray body (required by Qt for bodyless POST)
- Check for 204 No Content status code on success
- Emit taskClosed(taskId) on success
- Emit closeTaskFailed(taskId, error) on failure using handleNetworkError()

Key points:
- No response body expected (204 No Content)
- Use same error handling pattern as fetchAllTasks()
- Remember reply->deleteLater() on all code paths
  </action>
  <verify>
Build with `cd /home/reg/Remarkable_Todoist && mkdir -p build && cd build && cmake .. && make -j$(nproc)` - no compile errors
Grep for "closeTask" in todoist_client.cpp to confirm implementation exists
  </verify>
  <done>TodoistClient has working closeTask() method that POSTs to Todoist API and emits appropriate signals</done>
</task>

<task type="auto">
  <name>Task 2: Add setTaskCompleted() to TaskModel</name>
  <files>src/models/taskmodel.h, src/models/taskmodel.cpp</files>
  <action>
Add setTaskCompleted() method to TaskModel:

In taskmodel.h:
- Add public method: `void setTaskCompleted(const QString& taskId, bool completed);`

In taskmodel.cpp:
- Implement setTaskCompleted():
  - Find task by ID in m_tasks vector (linear scan, list is small)
  - If found and state changed, update task.completed
  - Create QModelIndex with index(i, 0)
  - Emit dataChanged(idx, idx, {CompletedRole}) for single row update
  - Return early if task not found or state unchanged

This follows the pattern from RESEARCH.md - emit dataChanged with specific role to trigger QML ListView update.

Critical: The roles vector must contain CompletedRole for QML to pick up the change. Use `QVector<int>{CompletedRole}` or initializer list `{CompletedRole}`.
  </action>
  <verify>
Build with `cd /home/reg/Remarkable_Todoist/build && make -j$(nproc)` - no compile errors
Grep for "setTaskCompleted" in taskmodel.cpp to confirm implementation exists
Grep for "dataChanged" in taskmodel.cpp to confirm signal emission exists
  </verify>
  <done>TaskModel has setTaskCompleted() that updates task state and emits dataChanged for proper QML binding</done>
</task>

</tasks>

<verification>
1. Project builds without errors
2. TodoistClient has closeTask() method with taskClosed/closeTaskFailed signals
3. TaskModel has setTaskCompleted() method with dataChanged emission
4. No new warnings introduced
</verification>

<success_criteria>
- Build passes with `cmake .. && make`
- closeTask() implemented with POST to /tasks/{id}/close
- setTaskCompleted() implemented with dataChanged signal emission
- Both methods follow established patterns in existing code
</success_criteria>

<output>
After completion, create `.planning/phases/02-sync-task-completion/02-01-SUMMARY.md`
</output>
