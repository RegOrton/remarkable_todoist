---
phase: 02-sync-task-completion
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/network/sync_manager.h
  - src/network/sync_manager.cpp
  - CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "SyncManager tracks online/offline state"
    - "SyncManager processes queue when online"
    - "SyncManager auto-syncs when connectivity restored"
  artifacts:
    - path: "src/network/sync_manager.h"
      provides: "SyncManager class declaration"
      contains: "class SyncManager"
    - path: "src/network/sync_manager.cpp"
      provides: "Connectivity and queue processing"
      contains: "processQueue"
    - path: "CMakeLists.txt"
      provides: "Build includes sync_manager"
      contains: "sync_manager.cpp"
  key_links:
    - from: "src/network/sync_manager.cpp"
      to: "src/network/todoist_client.h"
      via: "closeTask() call"
      pattern: "closeTask"
    - from: "src/network/sync_manager.cpp"
      to: "src/models/sync_queue.h"
      via: "queue operations"
      pattern: "SyncQueue"
---

<objective>
Create SyncManager class to orchestrate connectivity detection, queue processing, and sync operations.

Purpose: SyncManager is the coordinator between the offline queue, the Todoist API client, and connectivity state. It attempts sync when online, queues operations when offline, and auto-syncs when connectivity is restored.

Output: SyncManager class with isOnline property, pendingCount property, queueTaskCompletion(), processQueue(), and auto-sync on reconnect.
</objective>

<execution_context>
@/home/reg/.claude/get-shit-done/workflows/execute-plan.md
@/home/reg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-sync-task-completion/02-RESEARCH.md

# Dependencies from earlier plans (will exist after wave 1)
@src/network/todoist_client.h
@src/models/sync_queue.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SyncManager class</name>
  <files>src/network/sync_manager.h, src/network/sync_manager.cpp, CMakeLists.txt</files>
  <action>
Create SyncManager to orchestrate sync operations:

In sync_manager.h:
```cpp
#ifndef SYNC_MANAGER_H
#define SYNC_MANAGER_H

#include <QObject>
#include <QTimer>
#include "../models/sync_queue.h"

class TodoistClient;
class QNetworkInformation;

class SyncManager : public QObject
{
    Q_OBJECT
    Q_PROPERTY(bool isOnline READ isOnline NOTIFY isOnlineChanged)
    Q_PROPERTY(int pendingCount READ pendingCount NOTIFY pendingCountChanged)
    Q_PROPERTY(bool isSyncing READ isSyncing NOTIFY isSyncingChanged)

public:
    explicit SyncManager(TodoistClient* client, QObject* parent = nullptr);

    // Properties
    bool isOnline() const { return m_isOnline; }
    int pendingCount() const { return m_queue.count(); }
    bool isSyncing() const { return m_isSyncing; }

    // Queue a task completion operation
    void queueTaskCompletion(const QString& taskId);

    // Process pending operations (call when you think we're online)
    void processQueue();

signals:
    void isOnlineChanged();
    void pendingCountChanged();
    void isSyncingChanged();
    void syncSucceeded(const QString& taskId);
    void syncFailed(const QString& taskId, const QString& error);

private slots:
    void onTaskClosed(const QString& taskId);
    void onCloseTaskFailed(const QString& taskId, const QString& error);
    void onReachabilityChanged();
    void processNextOperation();

private:
    void initializeNetworkMonitoring();
    void setOnline(bool online);
    void setIsSyncing(bool syncing);

    TodoistClient* m_client;
    SyncQueue m_queue;
    QTimer m_retryTimer;

    bool m_isOnline;
    bool m_isSyncing;
    bool m_useNetworkInfo;        // Whether QNetworkInformation is available
    QString m_currentSyncTaskId;  // Task currently being synced
};

#endif // SYNC_MANAGER_H
```

In sync_manager.cpp:
- Constructor:
  - Initialize m_isOnline = true (optimistic)
  - Initialize m_isSyncing = false
  - Store TodoistClient pointer
  - Connect TodoistClient signals (taskClosed, closeTaskFailed)
  - Call initializeNetworkMonitoring()
  - Set up m_retryTimer with 2000ms interval, singleShot
  - Connect m_retryTimer.timeout to processNextOperation
  - Connect m_queue.countChanged to pendingCountChanged

- initializeNetworkMonitoring():
  - Try QNetworkInformation::loadDefaultBackend()
  - If available: connect reachabilityChanged signal, set m_useNetworkInfo = true
  - If not available: log warning, set m_useNetworkInfo = false (will detect offline via failed requests)

- queueTaskCompletion(taskId):
  - Check hasOperationForTask() to avoid duplicates
  - Create SyncOperation with QUuid, type="close_task", taskId, queuedAt=QDateTime::currentDateTime()
  - Call m_queue.enqueue(op)
  - Call processQueue() to attempt immediate sync

- processQueue():
  - If m_queue.isEmpty() or m_isSyncing: return
  - Call processNextOperation()

- processNextOperation():
  - If m_queue.isEmpty(): setIsSyncing(false); return
  - setIsSyncing(true)
  - SyncOperation op = m_queue.peek()
  - m_currentSyncTaskId = op.taskId
  - If op.type == "close_task": m_client->closeTask(op.taskId)

- onTaskClosed(taskId):
  - If taskId == m_currentSyncTaskId:
    - m_queue.dequeue() (remove successful operation)
    - emit syncSucceeded(taskId)
    - setOnline(true) (confirmed online)
    - processNextOperation() (continue with queue)

- onCloseTaskFailed(taskId, error):
  - If taskId == m_currentSyncTaskId:
    - setIsSyncing(false)
    - emit syncFailed(taskId, error)
    - Detect offline: if error contains "timeout" or "connection": setOnline(false)
    - If online, increment retryCount and try later with timer
    - If offline, wait for connectivity change

- onReachabilityChanged():
  - Get QNetworkInformation::instance()->reachability()
  - bool online = (reachability == QNetworkInformation::Reachability::Online)
  - setOnline(online)
  - If online and !m_queue.isEmpty(): start m_retryTimer (2 second delay before sync)

- setOnline(online):
  - If m_isOnline != online: m_isOnline = online; emit isOnlineChanged()

- setIsSyncing(syncing):
  - If m_isSyncing != syncing: m_isSyncing = syncing; emit isSyncingChanged()

In CMakeLists.txt:
- Add src/network/sync_manager.cpp to SOURCES

Key points from RESEARCH.md:
- QNetworkInformation may not work on reMarkable - use fallback to error-based detection
- Optimistic online - assume online until proven otherwise
- 2 second delay after connectivity restored before syncing (avoid race conditions)
- dequeue only AFTER server confirms success
  </action>
  <verify>
Build with `cd /home/reg/Remarkable_Todoist/build && cmake .. && make -j$(nproc)` - no compile errors
Grep for "QNetworkInformation" in sync_manager.cpp to confirm connectivity detection
Grep for "processQueue" in sync_manager.cpp to confirm queue processing
  </verify>
  <done>SyncManager class exists with connectivity tracking and queue processing</done>
</task>

</tasks>

<verification>
1. Project builds without errors
2. SyncManager has isOnline, pendingCount, isSyncing properties
3. queueTaskCompletion adds to queue and attempts sync
4. processQueue processes operations in FIFO order
5. Connectivity change triggers auto-sync with delay
</verification>

<success_criteria>
- Build passes with `cmake .. && make`
- SyncManager connects to TodoistClient for API calls
- SyncManager uses SyncQueue for persistence
- Online/offline state tracked and exposed as Q_PROPERTY
- Queue processes automatically when online
</success_criteria>

<output>
After completion, create `.planning/phases/02-sync-task-completion/02-03-SUMMARY.md`
</output>
